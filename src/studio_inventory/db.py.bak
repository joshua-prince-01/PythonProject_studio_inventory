from pathlib import Path
import sqlite3
import os
from contextlib import contextmanager

# ----------------------------
# Workspace root
# ----------------------------
def workspace_root() -> Path:
    """
    Runtime data folder.
    Defaults to ~/StudioInventory
    Override with STUDIO_INV_HOME.
    """
    env = os.getenv("STUDIO_INV_HOME")
    if env:
        return Path(env).expanduser().resolve()
    return (Path.home() / "StudioInventory").resolve()


def default_db_path() -> Path:
    root = workspace_root()
    root.mkdir(parents=True, exist_ok=True)
    return root / "studio_inventory.sqlite"


# ----------------------------
# Database wrapper
# ----------------------------
class DB:
    def __init__(self, path: Path | None = None):
        self.path = Path(path) if path else default_db_path()
        self.path.parent.mkdir(parents=True, exist_ok=True)

    @contextmanager
    def connect(self):
        conn = sqlite3.connect(self.path)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
            conn.commit()
        finally:
            conn.close()

    def execute(self, sql: str, params: tuple = ()):
        with self.connect() as conn:
            return conn.execute(sql, params)

    def executemany(self, sql: str, params: list[tuple]):
        with self.connect() as conn:
            return conn.executemany(sql, params)

    def query(self, sql: str, params: tuple = ()):
        with self.connect() as conn:
            cur = conn.execute(sql, params)
            return cur.fetchall()

    def executescript(self, sql: str):
        with self.connect() as conn:
            return conn.executescript(sql)
